<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Python Oddities Explained</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Python Oddities Explained</h1>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            Is everyone awake?
          </aside>
        </section>

        <!--

          - Make sure >>> is hidden in cases where there's something to be revealed
          - not too much on identity: maybe explain identity vs equality to setup mutability
          - remove [0] * 3 oddities
          - a += b is not always the same as a = a + b... but sometimes it is!
          - List can contain itself
          - final takaways:
            - Variables in Python are pointers: so variable assignments don't copy things, they just change the object that a particular variable name points to
            - the word change is ambiguous: "can't change variable X" could mean it's out of scope and can't be assigned to or could mean the object that X currently points to is immutable
            - containers don't contain objects, they just contain references to objects... two containers can "contain" to the same object and objects can "contain" themselves
            - += is not always the same as = +... it is for tuples, strings, and numbers, but not on lists

        -->

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos" alt="Truthful Technology"></a>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos" alt="Python Morsels"></a>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey
            - I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - And I run a Python exercise subscription service where where I send out 1 Python exercise every week.  It's called Python Morsels.
          </aside>
        </section>

        <section>
          <h1>I teach Python to teams</h1>
          <h3 class="fragment">My students show me very interesting code</h3>
          <h3 class="fragment"><q>That's odd.  What's going on here?</q></h3>
          <h3 class="fragment">Thanks for the questions!</h3>
          <aside class="notes" data-markdown>
            - So when I do on-site trainings, **(click)** I often get to see some very weird code because my students are *playing* with Python
            - Sometimes when I'm trying to explain what Python is doing, I realize... **(click)** I don't really understand what Python's doing, at least not well enough to explain it
            - This talk is dedicated to the people I've taught over the last few years
            - So to we everyone who's asked me a question that made pause: **(click)** thanks for give me this talk
          </aside>
        </section>

        <section>
          <h2>This talk supports Python 3 only</h2>
          <h3 class="fragment">Ask me what oddities Python 2 has</h3>
          <aside class="notes" data-markdown>
            - This is a Python 3 only talk
            - There are parts of this talk that may apply to Python 2, but I don't that everything will work quite the same way
            - So if you're on Python 2, you'll need to test these things out on your own
            - If this talk was a Python 2 oddities talk, it would be funnier and longer
            - So if you *are* on Python 2 and you'd like to me to help convince you to upgrade **(click)**, ask me about Python 2 oddities
          </aside>
        </section>

      </section>

      <!--
      <section>

        <section>
          <h2>Errors of Equality</h2>
          <aside class="notes" data-markdown>
            - Let's talk about equality
          </aside>
        </section>

        <section>
          <h3><span class="fragment" data-fragment-index=5>Equality </span><span class="fragment" data-fragment-index=6>and Identity</span></h3>
          <pre class="python"><code data-trim data-noescape>
>>> a = [1, 2]
>>> b = [1, 2]
>>> <span class="fragment" data-fragment-index=1>a == b</span>
<span class="fragment" data-fragment-index=2>True
>>> </span><span class="fragment" data-fragment-index=3>a is b</span>
<span class="fragment" data-fragment-index=4>False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have two lists, `a` and `b`.
            - They have the same items, so if we ask whether a is equal to be **(click)**, we'll see that this is True **(click)**
            - If we ask whether a **is** b **(click)**, we'll see that that's False **(click)**
            - The first question is asking about equality **(click)** between `a` and `b`
            - The second question is asking about identity **(click)**: we're asking whether `a` and `b` are exactly the same object in memory.  Which they aren't.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> a = [1, 2]
>>> b = [1, 2]
>>> <span class="fragment">a is b
False
>>> </span><span class="fragment">id(a), id(b)
(140678342682600, 140678342683752)
>>> </span><span class="fragment">c = a
>>> </span><span class="fragment">id(a), id(c)
(140678342682600, 140678342682600)
>>> </span><span class="fragment">a == c
True
>>> </span><span class="fragment">a is c
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - The question **(click)** `a is b` is asking whether the memory location of each these two objects is the same, **(click)** which it's not in this case
            - If we assign the variable `c` **(click)** to the variable `a`, we'll see that `c` and `a` now point to the same object in memory, **(click)** which means they're not just equal **(click)**: they're also identical **(click)**
            - If this is a little tricky to wrap your head around, don't worry because it'll come up again when we talk about mutability later
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 999
>>> </span><span class="fragment">y = 999
>>> </span><span class="fragment">x == y
</span><span class="fragment">True
>>> </span><span class="fragment">x is y
</span><span class="fragment">False
>>> </span><span class="fragment">x = 4
>>> </span><span class="fragment">y = 4
>>> </span><span class="fragment">x is y
</span><span class="fragment">True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's take two variables and assign them each to the same number.
            - `x` is `999` **(click)** and so is `y` **(click)**
            - Does `x` equal `y`? **(click)** *(pause)* Yes. **(click)**
            - Is `x` identical to `y`? **(click)** *(pause)* No **(click)**, they're not identical.  Python stores these two objects separately.
            - Somewhat strangely... if `x` **(click)** and `y` **(click)** are both `4`, and we ask the same question **(click)**... we'll see that this time `x` and `y` *are* identical **(click)**
            - What's going on here?
            - *(pause)*
            - So Python treats some numbers differently than others...
            - Some numbers will always be identical to the same number in Python
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
lots_of_numbers = range(-1000, 1000)
the_same_numbers = range(-1000, 1000)
same_numbers = (
    i
    for i, j in zip(lots_of_numbers, the_same_numbers)
    if i is j
)
print(*same_numbers, sep=", ")
          </code></pre>
          <aside class="notes" data-markdown>
            - We can see which numbers are special by looping over a wide range of numbers and printing out the ones that are identical to each other whenever they're equal... even when they'd normally be different objects in memory
          </aside>
        </section>

        <section>
          <pre class="no-highlight"><code class="hljs" data-trim style="overflow: hidden;">
-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112
113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,
243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256
          </code></pre>
          <aside class="notes" data-markdown>
            - The special numbers in Python are -5 through 256
            - The CPython runtime, that's the default python command that you run on your computer, it considers these numbers to be very common, so it stores them in memory at all times and makes sure that anytime we see one of these numbers, it uses the one that's already being stored, so it doesn't take up any extra memory
            - Python also does something similar for strings
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 'a' * 10
>>> y = 'a' * 10
>>> </span><span class="fragment">x is y
</span><span class="fragment">True
>>> </span><span class="fragment">x = 'a' * 1000
>>> y = 'a' * 1000
>>> </span><span class="fragment">x is y
</span><span class="fragment">False</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we have two fairly short strings **(click)** that are equal to each other, and we ask whether they're identical **(click)**, Python will tell us that they are **(click)**
            - But if we have longer strings **(click)** that are also equal to each other, and we ask whether they're identical **(click)**, Python will tell us that they aren't **(click)**
            - This isn't quite as straightforward as the integer optimization we just saw though
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> x = 'a' * 1000
>>> y = 'a' * 1000
>>> </span><span class="fragment">m = x[:10]
>>> n = y[:10]
>>> </span><span class="fragment">m is n
</span><span class="fragment">False
>>> </span><span class="fragment">m, n
('aaaaaaaaaa', 'aaaaaaaaaa')
>>> </span><span class="fragment">m == n
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Because if we take those long strings, and we slice them **(click)** to get short ones again
            - And then we ask whether those short strings are identical **(click)**, we'll see that they aren't **(click)**
            - Despite the fact that they represent the same characters **(click)**
            - And they are equal to each other **(click)**
          </aside>
        </section>

        <section>
          <h3>So... should you ever use the <code>is</code> operator?</h3>
          <h4 class="fragment">Yes, when you care about identity, not just equality</h4>
          <aside class="notes" data-markdown>
            - So at after these oddities, you might be thinking, the `is` operator seems like it's not actually very useful and might be misleading to use
            - But `is` *is* useful, it's just not as commonly useful as `==`
            - The `is` operator is useful **(click)** whenever you actually *care* whether two objects are identical... the same exact object in memory... and not just equal to each other
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
def from_node(node):
    node_list = []
    while <span class="fragment bold-current">node is not None</span>:
        node_list.append(node)
        node = node.next
    return node_list

<span class="fragment">def is_iterator(iterable):
    """Return True if the given iterable is also an iterator."""
    return iter(iterable) is iterable</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - PEP8, the official Python style guide, recommends using the `is` operator for comparisons with singletons **(click)** like `None` and `True` because they'll always be identical to each other
            - That's probably the most common use of the `is` operator in Python, but there are *other* uses
            - Relying on identity is useful if you want to know whether you're looking at two *different* objects or just *one* object with multiple names
            - For example **(click)** here we're checking whether an object is an iterator by seeing whether its iterator is identical to itself
            - So...
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Equality and identity are different</li>
            <li class="fragment">Checking for equality is very common</li>
            <li class="fragment">Checking for identity is not nearly as common</li>
            <li class="fragment">Python includes optimizations that make for strange identity patterns with strings and numbers</li>
            <li class="fragment">Checking for identity when you need equality causes bugs</li>
          </ul>
          <aside class="notes" data-markdown>
            - The takeaways from these equality and identity oddities are that...
            - **(click)** Equality and identity are not the same thing
            - **(click)** The `==` operator is much more commonly useful than the `is` operator
            - **(click)** If you're wondering whether you want equality or identity, most of the time you want equality
            - **(click)** Python includes some optimizations that involve making some strings and numbers identical when the aren't really
            - **(click)** So if you find yourself using `is` when you shouldn't, your code may actually have some very hard to catch bugs
          </aside>
        </section>

      </section>
      -->
      <section>

        <section>
          <h2>Scope Scares</h2>
          <aside class="notes" data-markdown>
            - First we're going to talk about variables
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment" data-fragment-index=1>x = 0
>>> </span><span class="fragment" data-fragment-index=2>numbers = [1, 1, 2, 3, 5, 8]
>>> </span><span class="fragment" data-fragment-index=3><span class="fragment bold-current" data-fragment-index=8>for x in numbers</span>:
...     y = x**2
...
>>> </span><span class="fragment" data-fragment-index=4>y</span>
<span class="fragment" data-fragment-index=5>64</span><span class="fragment" data-fragment-index=6>
>>> x</span>
<span class="fragment" data-fragment-index=7>8</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a variable `x` **(click)** that is equal to `0` and a variable `numbers` **(click)** that points to a list of numbers
            - If we loop **(click)** over this list of numbers and assign `y` to the square of each number
            - What will we see if we access `y` **(click)** after this loop?
            - **(click)** 64!
            - What will we see if we access `x` **(click)** now?
            - **(click)** 8!
            - Unlike many other programming languages, loops leak their scope in Python
            - Variables defined inside a loop are accessible outside of the loop
            - And that **(click)** `for x in numbers` in actually **an assignment** that happens during each iteration of our loop.  It works the same way as an assignment using an equals sign.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = 0
>>> </span><span class="fragment">numbers = [1, 1, 2, 3, 5, 8]
>>> </span><span class="fragment">squares = [x**2 for x in numbers]
>>> </span><span class="fragment">x</span>
<span class="fragment">0</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we take those same `x` **(click)** and `numbers` **(click)** variables and we make a list comprehension **(click)** representing the squares of these numbers and we use `x` **(click)** as our looping variable
            - What will `x` **(click)** be after we've executed all this code?
            - x is actually still 0 here **(click)**
            - ... In Python 3 that is.  In Python 2, list comprehensions used to leaked their scope, but in Python 3, list comprehensions have their own separate scope.
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> numbers = [1]
>>> <span class="fragment">class A:
...     numbers = [2]
...     m = 3
...     squares = [n**2 for n in numbers]
...
>>> </span><span class="fragment">numbers[0], A.numbers[0], A.m, A.squares[0]
</span><span class="fragment">(1, 2, 3, 4)</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's make a list, called `numbers`
            - And a class that has some attributes: `numbers`, `m`, and `squares`
            - I'd like you to consider what *this code* is going to print
            - We have two different `numbers` variables here, one that's global and one that it's in our class
            - Our `squares` variable is the result of a list comprehension that loops over `numbers` and squares each of the numbers
            - Which `numbers` variable is it using?  Will `A.squares[0]` be `1**2` or `2**2`?
            - It's 4, which is `2**2`.  While we're in the process of creating our class, we can access other variables we've defined inside our class.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">class A:
...     numbers = [2]
...     </span><span class="fragment">for n in numbers:
...         print(n**2)
...</span><span class="fragment">
4
>>> </span><span class="fragment">A.numbers
[2]
>>> </span><span class="fragment">A.n
2</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This works because classes have their scope
            - The variables that we assign inside class scope become class attributes
            - And we're actually allowed to write arbitrary code inside a class as we define it
            - So we can write a `for` loop inside our class definition... which probably isn't something you should ever do, but you can.  This is just code being executed just like it is anywhere else in Python.
            - The interesting thing is that our class has not only a `numbers` attribute, but also an attribute `n`.  This `A.n` is here because we were doing an assignment to `n` in each iteration of our loop.
            - Classes have their own scope, just like functions have their own scope.  All the variables defined inside class scope become class attributes after we've finished defining our class.
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">class A:
...     numbers = [1, 2]
...     m = 3
...     </span><span class="fragment">squares = [n**m for n in numbers]
...     </span><span class="fragment">print(squares[0])
...</span><span class="fragment">
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 3, in A
  File "&lt;stdin>", line 3, in &lt;listcomp>
NameError: name 'm' is not defined</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's define a list, a variable `m` and another list comprehension
            - This time our comprehension will raise `n` to the power of `m`
            - What is this going to print?
            - That was kind of trick question, because we actually get an error
            - Comprehension scope isn't allowed to access class scope
            - This might seem a little weird and it is really is pretty weird, but there's a good reason for this
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> class A:
...     numbers = [1, 2]
...     <span class="fragment">def hi(): print(numbers)
...     hi()
...</span><span class="fragment">
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in A
  File "<stdin>", line 3, in hi
NameError: name 'numbers' is not defined</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we define a function inside of a class definition
            - And then we call that function
            - We'll get an error if that function accesses variables that are within class scope
            - This happens this way because otherwise class scope would leak into the methods that live on your class... and that would be really weird
          </aside>
        </section>
        -->

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> <span class="fragment">NUMBERS = [1, 2, 3]
>>> </span><span class="fragment">def add_numbers(*numbers):
...     NUMBERS += numbers
...
>>> </span><span class="fragment">add_numbers([4, 5, 6])</span><span class="fragment">
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in add_numbers
UnboundLocalError: local variable 'NUMBERS' referenced before assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a global variable `NUMBERS` **(click)**
            - And we want to add more numbers to our list by using `+=` **(click)**
            - What will this do if we call `add_numbers` with the list `[4, 5, 6]`? **(click)**
            - It could modify `NUMBERS`.  It could make a local variable `NUMBERS`.  It could give an error.
            - It does give us an error **(click)**
            - The `+=` operator both reads from and assign to the variable on its left-hand side.  So we're trying to both read from a global variable and assign to a global variable.
            - Python doesn't like that
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> NUMBERS = [1, 2, 3]
>>> <span class="fragment">def set_numbers(*numbers):
...     print(NUMBERS)
...     NUMBERS = numbers
...</span><span class="fragment">
>>> set_numbers([4, 5, 6])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in set_numbers
UnboundLocalError: local variable 'NUMBERS' referenced before assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we make a function **(click)** that prints `NUMBERS` and then assigns to it, calling that function will also give us an error **(click)**
            - Variable names in Python functions cannot be both local and non-local/global in the same scope
            - So we can't read a global variable and then later write to a local variable with the same name.  Python doesn't allow that because that's probably a bug in your code.
            - We're allowed to **read** a global variable *without* writing to it
            - But if we assign to a variable, it's a local variable
            - So if we swap these two lines of code, our function won't give an error...
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> NUMBERS = [1, 2, 3]
>>> def set_numbers(*numbers):
...     <span class="fragment bold-current" data-fragment-index=5>NUMBERS = numbers</span>
...     print(NUMBERS)
...
>>> <span class="fragment" data-fragment-index=2>set_numbers(<span class="fragment bold-current" data-fragment-index=5>[4, 5, 6]</span>)
[4, 5, 6]
>>> </span><span class="fragment" data-fragment-index=4>NUMBERS
[1, 2, 3]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Our function prints the expected numbers **(click)**
            - But our global variable doesn't change **(click)**
            - Because we're assigning to a local variable here **(click)**
            - That global `NUMBERS` variable and that local `NUMBERS` variables have the same names but they're different variables that point to different objects
            - Assignments in Python only change your local scope
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape style="overflow: hidden;">
>>> NUMBERS = [1, 2, 3]
>>> <span class="fragment">def add_numbers(*numbers):
...     NUMBERS.extend(numbers)
...     print(NUMBERS)
...
>>> </span><span class="fragment">add_numbers([4, 5, 6])</span>
<span class="fragment">[1, 2, 3, 4, 5, 6]


</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we take our `add_numbers` function and use the `extend` **(click)** method instead of an assignment, is this any different?
            - What will Python do when we call this function **(click)** this time? *(pause)*  Will it print out 1, 2, 3, 4, 5, 6 or will it give us an error?
            - This actually works... **(click)**
            - When I said before that we can't change `NUMBERS`, I meant that we can't *assign* to the global `NUMBERS` variable
            - But we're not assigning to `NUMBERS`, we're mutating it... which we're allowed to do.  We can mutate any mutable object that we can get our hands on
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Reading global variables is perfectly fine</li>
            <li class="fragment">But don't try to assign to them from a local scope</li>
            <li class="fragment">List comprehensions have their own scope</li>
            <li class="fragment">Scope matters with assignment, not with mutation</li>
          </ul>
          <aside class="notes" data-markdown>
            - So you're allowed to *read* from global variables in Python
            - But you can only write to local variables: every assignment statement assigns to a *local* variable
            - There are some escape hatches in the language to get around that which you usually shouldn't use and I'm not going to explain, but in general you should assume that assignments only work for local variables
            - List comprehensions have their own scope
            - Scope rules are entirely about assignment.  You don't need to worry about scope if you're just mutating an object.  It's when you're assigning that things get weird.
            - That leads us to our next topic...
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Teenage Mutable Ninja Turtles</h2>
          <aside class="notes" data-markdown>
            - Mutability: that's changing objects, not variables
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">numbers = [1, 2, 3]
>>> </span><span class="fragment">numbers2 = numbers
>>> </span><span class="fragment">numbers2.append(4)
>>> </span><span class="fragment">numbers2
[1, 2, 3, 4]
>>> </span><span class="fragment">numbers
</span><span class="fragment">[1, 2, 3, 4]
>>> </span><span class="fragment">id(numbers)
139670455619848
>>> id(numbers2)
139670455619848
>>> </span><span class="fragment">numbers is numbers2
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's say we have a list of `numbers`
            - And we assign `numbers2` to `numbers`
            - If we append to `numbers2`, how many elements will `numbers2` contain now?
            - `numbers2` has 4 things in it
            - How many things does `numbers` have?
            - `numbers` *also* has 4 things
            - We're referencing *the same object* with *two* different names
            - Mutating one of these lists, mutates the other... because they're **the same** list
            - **Objects** are *distinct* from the **variables** that point to them
            - "Changing" a *variable* means changing **which object** the variable points to... the only way to do that is through assignment
            - And nothing gets copied during an assignment, we're just giving another name to an object
            - "Changing" an *object* means **mutating** the object itself.  And any number of variables might be pointing to that object that you're changing.
            - Variables in Python are **not buckets** that contain objects
            - Python's variables are pointers that refer to the memory location that objects live at
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">[0] * 3
</span><span class="fragment">[0, 0, 0]
>>> </span><span class="fragment">[[0] * 3] * 3
</span><span class="fragment">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> </span><span class="fragment">matrix = [[0] * 3] * 3
>>> </span><span class="fragment">matrix[1][1] = 1
>>> </span><span class="fragment">matrix
</span><span class="fragment">[[0, 1, 0], [0, 1, 0], [0, 1, 0]]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - What will this give us? **(click)**
            - This gives us a list of three zeros. **(click)**  We're allowed to multiply lists by numbers in Python, the same way we can multiple strings by numbers (which I think I did earlier)
            - What will this give us? **(click)** *(pause)*
            - This gives us a list of three lists **(click)**, each with three zeroes in them.
            - So this **(click)** `matrix` variable now points to a list of lists of numbers
            - When we assign `matrix[1][1]` to the number `1` **(click)**
            - What will change in `matrix`? **(click)**
            - This actually changes the middle number in all three of the inner lists **(click)**
            - Let's take a look at what's going on here... with a little aside
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">row = [0, 0, 0]
>>> </span><span class="fragment">matrix = [row, row, row]
>>> </span><span class="fragment">row[1] = 2
>>> </span><span class="fragment">matrix
</span><span class="fragment">[[0, 2, 0], [0, 2, 0], [0, 2, 0]]
>>> </span><span class="fragment">matrix[1][1] = 1
>>> </span><span class="fragment">matrix
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
>>> </span><span class="fragment">matrix[0] is matrix[1] is row
True
>>> </span><span class="fragment">matrix = [row] * 3
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we have a list of zeroes that we assign to the `row` variable, and we make a new list that contains that `row` variable three times
            - We'll have made a list that contains the same exact list three times
            - If we modify that `row` list, and we look at our `matrix` afterward, we'll see that all of our matrix rows have been modified.  We modified one list that was stored in that list three times.
            - Likewise, if we modify any one of those row lists by indexing them, it'll modify all three rows
            - All of these things are identical.  They all refer to exactly the same object in memory.
            - TODO [row] * 3 is the same as [row, row, row]
          </aside>
        </section>
        -->

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = ([1], [4])</span><span class="fragment">
>>> </span><span class="fragment">x[0].append(2)</span><span class="fragment">
>>> </span><span class="fragment">x
([1, 2], [4])
>>> </span><span class="fragment">y = x[0]
>>> </span><span class="fragment">y.append(3)
>>> </span><span class="fragment">x
([1, 2, 3], [4])</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If we make a **(click)** tuple of lists, will Python allow this?  Is that valid?
            - It is! **(click)**  Python allows us to put lists inside of tuples
            - What if call the **(click)** `append` method on the first list in this tuple?  Will Python allow that?
            - It will!  **(click)**  Python doesn't give an error here.
            - This tuple now has a list in it that has two items **(click)**, but it had only one item in it before
            - Tuples in Python are **immutable**, meaning we cannot change them.  And we haven't changed this tuple... at least not from Python's perspective.
            - Not only are Python's variables not buckets that contain things, tuplesalso aren't buckets that contain things.
            - Python's data structures don't contain objects, they contain references to objects.
            - If we take the first list in this tuple and assign it to a new variable **(click)**, and then append to the list in that new variable **(click)**, we'll have changed that list everywhere that it's referenced **(click)**
            - Variables and data structures both store references to objects, not the objects themselves
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> x = []
>>> <span class="fragment">x.append(x)
</span><span class="fragment">>>> <span class="fragment">x
[[...]]
>>> </span><span class="fragment">[[...]]</span><span class="fragment">
[[Ellipsis]]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - What will happen if we make a new list, and then try to append that list to itself? **(click)**  Will Python allow this?
            - *(pause)* It will! **(click)**
            - Python represents this a bit strangely **(click)**, using three ellipsis so that we know that this is an infinitely recursive object
            - Python allows us to put lists inside themselves because lists don't actually contain objects, they just contain pointers to objects **(click)**
            - That notion of **containment** is a *convenient* way to think of things, but it's not like containment in the real world.
            - Python's containment is less like buckets and more like a lookup table.  Variables don't actually contain the object, they just tell Python where to go to locate the object.
            - By the way, and this is completely unrelated...
            - **(click)** if you type a couple lists with three dots in them, that's, *somewhat strangely*, valid Python code **(click)**
            - I'm not going to explain what's going on here.  If you look up Python Ellipsis, you can take a look at that one on your own.
            - Alright moving on...
          </aside>
        </section>

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">Lists and dictionaries don't "contain" objects, they contain references (pointers) to objects</li>
            <li class="fragment">Variables in Python are not buckets that contain things</li>
            <li class="fragment">Variables are names that point to objects</li>
            <li class="fragment">Assigning to a variable changes what object it points to</li>
            <li class="fragment">Mutating an object changes the object itself</li>
            <li class="fragment">Watch <a href="https://www.youtube.com/watch?v=_AEJHKGk9ns">Facts and Myths about Python names and values</a></li>
            <li class="fragment">Watch <a href="https://pyvideo.org/pyohio-2011/pyohio-2011-names-objects-and-plummeting-from.html">Names, Objects, and Plummeting From The Cliff</a></li>
          </ul>
          <aside class="notes" data-markdown>
            - Data structures in Python, like lists and dictionaries, don't contain objects, the contain pointers to objects
            - Variables in Python also don't contain objects **(click)**, they just point to objects **(click)**
            - Changing *variables* means changing pointers **(click)**
            - Changing *objects* means mutating that object **(click)**
            - Assignments and mutations are unrelated: but we use the word **change** to talk about both of them
            - Remember that the word *change* is very ambiguous word: assigning and mutating are very different types of change
            - You can also think of this another way: assignment never copies things, it just points a name to an object
            - If you feel rusty on this topic, there's two talks I'd recommend watching...
              - Facts and Myths about Python names values by Ned Batchelder
              - And Names, Objects, and Plummeting From The Cliff by Brandon Rhodes
            - *(pause)* Alright we have one more more topic I'd like to play with...
          </aside>
        </section>

      </section>
      <section>

        <section>
          <h2>Intriguing In-Place Additions</h2>
          <aside class="notes" data-markdown>
            - The last thing we'll discuss is `+=`
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">a = b = (1, 2)
>>> </span><span class="fragment">a += (3, 4)</span><span class="fragment">
>>> </span><span class="fragment">a
(1, 2, 3, 4)
>>> </span><span class="fragment">b
</span><span class="fragment">(1, 2)</span>
<span class="fragment">>>> a = a + (3, 4)</span>

          </code></pre>
          <aside class="notes" data-markdown>
            - Let's take two variables **(click)** and assign them to the same tuple
            - Then let's try to use the `+=` operator **(click)** to modify one of these tuples.  Will Python allow us to do this?
            - *(pause)* It will!  **(click)**
            - We can use `+=` **(click)** on tuples
            - What is our second tuple at this point?  **(click)**
            - Does it have 4 elements or does it still have 2? *(pause)*
            - It still has two.  **(click)**
            - When we use `+=` on a tuple it's the same **(click)** as if we'd used a `+` sign with assignment
            - We're not mutating the tuple, we're just making a new tuple and reassigning our variable to it
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">a = b = [1, 2]
>>> </span><span class="fragment">a += [3, 4]
>>> </span><span class="fragment">a
[1, 2, 3, 4]
>>> </span><span class="fragment">b
</span><span class="fragment">[1, 2, 3, 4]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's take two variables **(click)** and assign them to the same list
            - Then let's use the `+=` operator **(click)** to modify the first list **(click)**
            - What will the **(click)** second list be at this point?
            - Will it have just two elements or will it have four?
            - It will have four. **(click)**  When we use `+=` on a list it mutates our list
            - The `+=` operator doesn't mutate tuples, but it does mutate lists
            - I find this very interesting...
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> a = b = [0]
>>> <span class="fragment" data-fragment-index=1><span class="fragment bold-current" data-fragment-index=3>a += b</span>
>>> len(a), len(b)
<span class="fragment bold-current" data-fragment-index=3>(2, 2)</span>
>>> </span><span class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>a = a + b</span>
>>> len(a), len(b)
<span class="fragment bold-current" data-fragment-index=4>(4, 2)</span>
</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Because this means that on lists, `a += b` **(click)** is doing a mutation, but `a = a + b` **(click)** just does an assignment
            - So in Python, **(click)** `a += b` is not always the same as **(click)** `a = a + b`
            - It is for **tuples**, but it *isn't* for **lists**
            - Before we take a look at what's going on here, we're going to look at one more bit of code...
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = [1, 2]
>>> </span><span class="fragment">x += (3, 4)</span><span class="fragment">
>>> x</span><span class="fragment">
[1, 2, 3, 4]
>>> </span><span class="fragment">y = (1, 2)
>>> </span><span class="fragment">y += [3, 4]
</span><span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can only concatenate tuple (not "list") to tuple</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = []
>>> </span><span class="fragment">x += "hey"
>>> </span><span class="fragment">x
['h', 'e', 'y']
>>> </span><span class="fragment">x.extend('iterable')
>>> </span><span class="fragment">x
['h', 'e', 'y', 'a', 'i', 't', 'e', 'r', 'a', 'b', 'l', 'e']</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO lists are the odd one here
          </aside>
        </section>
        -->

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">x = ([1, 2],)
>>> </span><span class="fragment">x[0] += [3, 4]
</span><span class="fragment">Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment
>>> </span><span class="fragment">x
([1, 2, 3, 4],)</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Let's take a tuple with a list inside it.  We've already seen that we can store lists inside of tuples.  And we also know we can mutate lists that are inside tuples.
            - So what will happen if we say **(click)** `x[0] += [3, 4]`
            - Will it mutate the list?  Or will it give us an error?
            - *(pause)* It gives us an error **(click)**
            - *And* it mutates the list **(click)**
            - So everyone's happy!
            - *(pause)*  This is a very obscure quirk of the way Python does `+=` and it's never going to bite you in real code, but let's take a look at what's going on
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> x = ([1, 2],)
>>> <span class="fragment" data-fragment-index=2><span class="bold-current fragment" data-fragment-index=4>x[0] =</span> x[0].<span class="bold-current fragment" data-fragment-index=3>__iadd__([3, 4])</span>  # x[0] += [3, 4]</span>
<span class="fragment" data-fragment-index=5>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment
>>> </span><span class="fragment" data-fragment-index=6>x[0]
[1, 2, 3, 4]
>>> </span><span class="fragment" data-fragment-index=7>x[0].__iadd__([5])
[1, 2, 3, 4, 5]
>>> </span><span class="fragment" data-fragment-index=8>x[0] = [1, 2, 3, 4, 5]
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'tuple' object does not support item assignment</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Whenever we use `+=` **(click)**, Python will try to call **(click)** `\_\_iadd\_\_` on the object that we're pointing to and then it will also **(click)** do an assignment assignment
            - So we **(click)** do get an exception from that assignment statement, but only *after* **(click)** `\_\_iadd\_\_` modifies our list object
            - The *list* `\_\_iadd\_\_` method, **(click)** mutates our list and returns the same list to for the sake of the assignment
            - But we're **(click)** not allowed to assign into tuples
          </aside>
        </section>

        <!--
        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">NUMBERS = [1, 2, 3]
>>> </span><span class="fragment">class MyFavoriteClass:
...     NUMBERS += [4, 5, 6]
...</span><span class="fragment">
>>> </span><span class="fragment">MyFavoriteClass.NUMBERS
[1, 2, 3, 4, 5, 6]
>>> </span><span class="fragment">NUMBERS
</span><span class="fragment">[1, 2, 3, 4, 5, 6]</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">VOWELS = "aeiou"
>>> </span><span class="fragment">class B:
...     VOWELS += "y"
...</span><span class="fragment">
>>> </span><span class="fragment">B.VOWELS
'aeiouy'
>>> </span><span class="fragment">VOWELS
'aeiou'</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>
        -->

        <section>
          <h2>Takeaways</h2>
          <ul>
            <li class="fragment">In-place addition (<code>+=</code>) and other augmented assignment operations perform assignments</li>
            <li class="fragment">In-place addition calls the <code>__iadd__</code> method which allows the object to mutate itself if it chooses to do so</li>
            <li class="fragment">Python's choice about what makes for consistent behavior may differ from your own assumptions</li>
          </ul>
          <aside class="notes" data-markdown>
            - **(click)** The `+=` operator always performs an assignment
            - But this operator and the other augmented assignment operators **(click)** are also allowed to mutate the object their called with... if the object chooses to do so
            - Lists mutate themselves with `+=` and tuples don't.  This `+=` on lists consistent with their `extend` but inconsistent with `+=` on tuples
            - **(click)** Trade offs are everywhere when designing a programming language and what's consistent and what's *not* consistent really depends on your *mental model* of Python
          </aside>
        </section>

      </section>

      <section>

        <section>
          <h2>Closing thoughts</h2>
          <ul>
            <li class="fragment">Understanding how variables, mutability, and data structures work is important</li>
            <li class="fragment">If it looks like a bug, it might just be a misunderstanding</li>
            <li class="fragment">Found something odd? Try to learn from it!</li>
          </ul>
          <aside class="notes" data-markdown>
            - Regardless of what programming language you're in, **(click)** it's important to understand how the fundamentals of your programming language is different: how do function calls work, how variables work, and do objects works?
            - And if you think you found a bug in Python, **(click)** it might just be that you're misunderstanding what trade offs the Python code developers had to make when they chose the particular functionality that you're seeing
            - So if you see something odd going on, *before* you fix your code, **(click)** poke around and see whether you can learn from it
            - breaking things is one of *the best* ways to learn
          </aside>
        </section>

        <section>
          <h1>#pythonoddity</h1>
          <aside class="notes" data-markdown>
            - And if you find a Python oddity of your own, use the pythonoddity hashtag if you're going to tweet it, so others can find it too
          </aside>
        </section>

      </section>

			<section>

        <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
          <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
          <h3>
            <strong>Trey Hunner</strong><br>
            <small>Python &amp; Django Team Trainer</small>
          </h3>
          <p>
            <small>
              Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
            </small>
          </p>
          <p>
          <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
          <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
          </p>
          <aside class="notes" data-markdown>
            - I would love to help you and your team improve your Python skills.  Find me in the halls or send me an email
            - Thank you!
          </aside>
        </section>

        <section>
          <pre class="python"><code data-trim data-noescape>
>>> <span class="fragment">'8' &lt; 8
</span><span class="fragment">False
>>> </span><span class="fragment">'8' &lt; 9
</span><span class="fragment">False
>>> </span><span class="fragment">'8' &lt; 99999999999999999999999999999999
</span><span class="fragment">False
>>> </span><span class="fragment">[8] > 8</span><span class="fragment">
True
>>> </span><span class="fragment">[8] &lt; '8'
True
>>> </span><span class="fragment">sorted([str(type(8)), str(type('8')), str(type([8]))])
["&lt;type 'int'>", "&lt;type 'list'>", "&lt;type 'str'>"]
>>> </span><span class="fragment">8 &lt; [8] &lt; '8'
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - Is the string 8 less than the number 8?  **(click)**  What do you think Python 2 will tell us here.
            - No, **(click)** the string 8 is *not* less than the number 8
            - Is the string 8 less than the number 9?  **(click)**
            - No the string 8 is not less than the number 9.  **(click)**
            - What about this?  Is the string 8 less than a very large number?  **(click)**
            - That's not true either.  **(click)**
            - Is a list with the number 8 inside it greater than the number 8?  **(click)**
            - Why, yes it is!  **(click)**
            - But a list with 8 inside it is less than **(click)** the string 8
            - Python 2 allows all objects to be ordered.
            - Objects that it doesn't understand *how* to order are ordered by their class name **(click)**
            - **(click)** The string 'int' is less than the string 'list' which is less than the string 'str'
            - Be careful with Python 2
          </aside>
        </section>

      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>


    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
